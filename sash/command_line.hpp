/******************************************************************************
 *                   ____     ______   ____     __  __                        *
 *                  /\  _`\  /\  _  \ /\  _`\  /\ \/\ \                       *
 *                  \ \,\L\_\\ \ \L\ \\ \,\L\_\\ \ \_\ \                      *
 *                   \/_\__ \ \ \  __ \\/_\__ \ \ \  _  \                     *
 *                     /\ \L\ \\ \ \/\ \ /\ \L\ \\ \ \ \ \                    *
 *                     \ `\____\\ \_\ \_\\ `\____\\ \_\ \_\                   *
 *                      \/_____/ \/_/\/_/ \/_____/ \/_/\/_/                   *
 *                                                                            *
 *                                                                            *
 * Copyright (c) 2014                                                         *
 * Matthias Vallentin <vallentin (at) icir.org>                               *
 * Dominik Charousset <dominik.charousset (at) haw-hamburg.de>                *
 *                                                                            *
 * Distributed under the Boost Software License, Version 1.0. See             *
 * accompanying file LICENSE or copy at http://www.boost.org/LICENSE_1_0.txt  *
\******************************************************************************/

#ifndef SASH_COMMAND_LINE_HPP
#define SASH_COMMAND_LINE_HPP

#include <map>
#include <memory>
#include <vector>

#include "sash/color.hpp"

namespace sash {

/// An abstraction for a mode-based command line interace (CLI). The CLI offers
/// multiple *modes* each of which contain a set of *commands*. At any given
/// time, one can change the mode of the command line by pushing or popping a
/// mode from the mode stack. Each mode has a distinct prompt and command
/// history. A command is a recursive element consisting of zero or more
/// space-separated sub-commands. Each command has a description and a callback
/// handler for arguments which themselves are not commands.
/// @tparam Backend The CLI implementation, e.g., libedit.
/// @tparam Callback The callback function for command arguments.
template<class Backend, class Callback>
class command_line
{
public:
  /// The callback function for command arguments.
  /// The string argument represents the argument of the command.
  /// The return value indicates whether the callback succeeded.
  using callback = std::function<result<bool>(std::string)>;

  /// A unique pointer to our backend.
  using backend_ptr = std::unique_ptr<Backend>;

  /// A command-line context with its own commands, history, and prompt.
  class mode : intrusive_base<mode>
  {
    friend command_line;

    mode(mode const&) = delete;
    mode& operator=(mode const&) = delete;

  public:
    /// Constructs a mode.
    /// @param name The name of the mode.
    /// @param prompt The prompt string.
    /// @param prompt_color The color of *prompt*.
    /// @param history_file The file where to store the mode history.
    mode(std::string name, std::string prompt, char const* prompt_color, std::string history_file);

    /// Adds a sub-command to this command.
    /// @param name The name of the command.
    /// @param desc A one-line description of the command.
    /// @returns If successful, a valid pointer to the newly created command.
    std::shared_ptr<command> add(std::string name, std::string desc);

    /// Assigns a callback handler for unknown commands.
    /// @param f The function to execute for unknown commands.
    void on_unknown_command(callback f);

    /// Assigns a callback handler for unknown commands.
    /// @param f The function to execute for unknown commands.
    void on_complete(editline::completer::callback f);

    /// Registers a completion with this mode.
    /// @param The string to register.
    void complete(std::string str);

    /// Replaces the completions associated with a set of new ones.
    /// @param completiosn The new completions.
    void complete(std::vector<std::string> completions);

    /// Execute a command line.
    result<bool> execute(std::string args) const;

    /// Retrieves the name of this mode.
    /// @returns The name of this mode
    std::string const& name() const;

    /// Retrieves the autogenerated help string for this mode.
    /// @param indent The number of spaces to indent the help text.
    /// @returns The help string for this mode.
    std::string help(size_t indent = 0) const;

  private:
    std::shared_ptr<command> root_;
    editline::history history_;
    editline el_;
  };

  /// Creates a new mode for a set of related commands. Only one mode can
  /// be active at a time. Each mode has its own history.
  ///
  /// @param name The name of the mode.
  ///
  /// @param prompt The prompt of the mode.
  ///
  /// @param prompt_color The color of *prompt*.
  ///
  /// @param history_file The filename of the history.
  ///
  /// @returns A valid pointer to the new mode on success.
  std::shared_ptr<mode> mode_add(std::string name,
                               std::string prompt,
                               char const* prompt_color = nullptr,
                               std::string history_file = "");

  /// Execute a command line.
  result<bool> execute(std::string args) const;

  /// Removes an existing mode.
  /// @param name The name of the mode.
  /// @returns `true` on success.
  bool mode_rm(std::string const& name);

  /// Enters a given mode.
  /// @param mode The name of mode.
  /// @returns `true` on success.
  bool mode_push(std::string const& mode);

  /// Leaves the current mode.
  /// @returns The number of modes left on the stack.
  size_t mode_pop();

  /// Appends an entry to the history of the current mode.
  /// @param entry The history entry to add.
  /// @returns `true` on success.
  bool append_to_history(std::string const& entry);

  /// Processes a single command from the command line.
  /// @param cmd The command to process.
  /// @returns A valid result if the callback executed and an error on failure.
  result<bool> process(std::string cmd);

  /// Retrieves a single character from the command line in a blocking fashion.
  /// @param c The result parameter containing the character from STDIN.
  /// @returns `true` on success, `false` on EOF, and an error otherwise.
  trial<bool> get(char& c);

  /// Retrieves a full line from the command line in a blocking fashion.
  /// @param line The result parameter containing the line.
  /// @returns `true` on success, `false` on EOF, and an error otherwise.
  trial<bool> get(std::string& line);

  /// Sets a (colored) string as prompt for the shell.
  inline void set_prompt(std::string str, color::type strcolor = color::none)
  {
    prompt_.clear();
    add_to_prompt(std::move(str), strcolor);
  }

  /// Appends a (colored) string to the prompt.
  inline void add_to_prompt(std::string str, color::type strcolor = color::none)
  {
    if (! str.empty())
    {
      auto& pr = backend_->prompt();
      if (strcolor != color::none)
      {
        ptr += strcolor;
        ptr += std::move(str);
        ptr += color::reset;
      }
      else
      {
        pr += std::move(str);
      }
      backend_->update_prompt();
    }
  }

  /// Returns the current prompt.
  std::string const& prompt() const
  {
    return prompt_;
  }

  /// Shortcut for <tt>prompt().c_str()</tt>.
  const char* cprompt() const
  {
    return prompt_.c_str();
  }

private:
  std::vector<std::shared_ptr<mode>> mode_stack_;
  std::map<std::string, std::shared_ptr<mode>> modes_;
  backend_ptr backend_;

};

} // namespace sash

#endif
